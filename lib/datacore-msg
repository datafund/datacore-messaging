#!/usr/bin/env python3
"""
datacore-msg - Terminal messenger for Datacore

Pure terminal messaging - no GUI, socket-based notifications.
Supports both local (Unix socket) and remote (WebSocket relay) modes.

Usage:
    datacore-msg                    # Interactive mode
    datacore-msg send @user "msg"   # Send message
    datacore-msg read               # Read inbox
    datacore-msg watch              # Watch for new messages
    datacore-msg peers              # List online peers
    datacore-msg daemon             # Run notification daemon
    datacore-msg login              # Authenticate with relay server
    datacore-msg connect            # Connect to relay (after login)

Examples:
    datacore-msg send @crt "Need OAuth keys"
    datacore-msg send @claude "Research competitor pricing"
"""

import argparse
import asyncio
import json
import os
import sys
import fcntl
from pathlib import Path
from datetime import datetime

# Optional websockets for relay
try:
    import websockets
    HAS_WEBSOCKETS = True
except ImportError:
    HAS_WEBSOCKETS = False

# === CONFIG ===

DATACORE_ROOT = Path(os.environ.get("DATACORE_ROOT", Path.home() / "Data"))
SOCK_DIR = Path("/tmp")
CLAUDE_PIPE = Path("/tmp/datacore-claude.pipe")
DEFAULT_RELAY = "wss://datacore-relay.fly.dev"


def get_settings() -> dict:
    """Load settings from yaml."""
    settings = DATACORE_ROOT / ".datacore/settings.local.yaml"
    if settings.exists():
        try:
            import yaml
            return yaml.safe_load(settings.read_text()) or {}
        except:
            pass
    return {}


def get_username() -> str:
    """Get current user identity."""
    if "DATACORE_USER" in os.environ:
        return os.environ["DATACORE_USER"]

    conf = get_settings()
    name = conf.get("identity", {}).get("name")
    if name:
        return name

    return os.environ.get("USER", "unknown")


def get_default_space() -> str:
    """Get default messaging space."""
    conf = get_settings()
    space = conf.get("messaging", {}).get("default_space")
    if space:
        return space

    for p in sorted(DATACORE_ROOT.glob("[1-9]-*")):
        if p.is_dir():
            return p.name

    return "1-team"


def get_relay_url() -> str:
    """Get relay server URL from settings."""
    conf = get_settings()
    return conf.get("messaging", {}).get("relay", {}).get("url", DEFAULT_RELAY)


def get_relay_secret() -> str | None:
    """Get relay shared secret from settings."""
    conf = get_settings()
    return conf.get("messaging", {}).get("relay", {}).get("secret")


def is_relay_enabled() -> bool:
    """Check if relay is enabled in settings."""
    conf = get_settings()
    relay_conf = conf.get("messaging", {}).get("relay", {})
    # Enabled if explicitly set or if secret is configured
    return relay_conf.get("enabled", False) or bool(relay_conf.get("secret"))


def get_socket_path(user: str) -> Path:
    """Get socket path for user."""
    return SOCK_DIR / f"datacore-msg-{user}.sock"


# === MESSAGE STORE ===

def write_message(to: str, text: str, priority: str = "normal") -> str:
    """Write message to recipient's inbox. Returns message ID."""
    from_user = get_username()
    space = get_default_space()

    inbox_dir = DATACORE_ROOT / space / "org/inboxes"
    inbox_dir.mkdir(parents=True, exist_ok=True)
    inbox = inbox_dir / f"{to}.org"

    now = datetime.now()
    msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-{from_user}"
    timestamp = now.strftime("[%Y-%m-%d %a %H:%M]")

    entry = f"""
* MESSAGE {timestamp} :unread:
:PROPERTIES:
:ID: {msg_id}
:FROM: {from_user}
:TO: {to}
:PRIORITY: {priority}
:END:
{text}
"""

    with open(inbox, "a") as f:
        fcntl.flock(f, fcntl.LOCK_EX)
        f.write(entry)
        fcntl.flock(f, fcntl.LOCK_UN)

    return msg_id


def read_messages(unread_only: bool = True) -> list:
    """Read messages from current user's inbox."""
    username = get_username()
    messages = []

    for inbox in DATACORE_ROOT.glob(f"*/org/inboxes/{username}.org"):
        space = inbox.parts[-4]  # e.g., "1-datafund"
        content = inbox.read_text()

        for block in content.split("\n* MESSAGE ")[1:]:
            lines = block.split("\n")
            header = lines[0] if lines else ""

            is_unread = ":unread:" in header
            if unread_only and not is_unread:
                continue

            # Parse timestamp
            time_str = ""
            if "[" in header and "]" in header:
                ts = header[header.find("[")+1:header.find("]")]
                time_str = ts

            # Parse properties
            props = {}
            text_lines = []
            in_props = False

            for line in lines[1:]:
                if ":PROPERTIES:" in line:
                    in_props = True
                elif ":END:" in line:
                    in_props = False
                elif in_props and ": " in line:
                    line = line.strip()
                    if line.startswith(":"):
                        kv = line[1:].split(": ", 1)
                        if len(kv) == 2:
                            props[kv[0].lower()] = kv[1]
                elif not in_props and line.strip():
                    text_lines.append(line)

            messages.append({
                "id": props.get("id", ""),
                "from": props.get("from", "?"),
                "to": props.get("to", ""),
                "text": "\n".join(text_lines).strip(),
                "time": time_str,
                "space": space,
                "unread": is_unread,
                "priority": props.get("priority", "normal"),
            })

    return sorted(messages, key=lambda m: m.get("id", ""))


# === LOCAL SOCKET NOTIFICATIONS ===

class NotificationDaemon:
    """Simple daemon that listens for message notifications."""

    def __init__(self, username: str):
        self.username = username
        self.socket_path = get_socket_path(username)

    async def start(self):
        """Start the daemon."""
        self.socket_path.unlink(missing_ok=True)

        server = await asyncio.start_unix_server(
            self.handle_connection,
            path=str(self.socket_path)
        )

        print(f"[daemon] @{self.username} listening on {self.socket_path}")

        async with server:
            await server.serve_forever()

    async def handle_connection(self, reader, writer):
        """Handle incoming connection."""
        try:
            while True:
                data = await reader.readline()
                if not data:
                    break

                msg = json.loads(data.decode())
                response = await self.handle_message(msg)

                if response:
                    writer.write((json.dumps(response) + "\n").encode())
                    await writer.drain()
        except:
            pass
        finally:
            writer.close()

    async def handle_message(self, msg: dict) -> dict:
        """Process incoming notification."""
        msg_type = msg.get("type")

        if msg_type == "ping":
            from_user = msg.get("from")
            print(f"\nðŸ”” New message from @{from_user}")

            # Forward to Claude if we're the claude daemon
            if self.username == "claude":
                await self.forward_to_claude(msg)

            return {"type": "pong"}

        elif msg_type == "presence":
            return {"type": "presence", "user": self.username, "status": "online"}

        return None

    async def forward_to_claude(self, msg: dict):
        """Forward message to Claude Code session via pipe."""
        if not CLAUDE_PIPE.exists():
            try:
                os.mkfifo(CLAUDE_PIPE)
            except:
                return

        try:
            fd = os.open(CLAUDE_PIPE, os.O_WRONLY | os.O_NONBLOCK)
            text = f"ðŸ“¬ Message from @{msg.get('from')}: Check /my-messages\n"
            os.write(fd, text.encode())
            os.close(fd)
        except:
            pass

    def cleanup(self):
        """Clean up socket."""
        self.socket_path.unlink(missing_ok=True)


async def notify_peer_local(user: str, msg_id: str) -> bool:
    """Send notification to peer via local socket."""
    socket_path = get_socket_path(user)
    if not socket_path.exists():
        return False

    try:
        reader, writer = await asyncio.open_unix_connection(str(socket_path))
        msg = {"type": "ping", "from": get_username(), "msg_id": msg_id}
        writer.write((json.dumps(msg) + "\n").encode())
        await writer.drain()

        response = await asyncio.wait_for(reader.readline(), timeout=1.0)
        writer.close()
        await writer.wait_closed()
        return True
    except:
        return False


def list_online_peers_local() -> list:
    """List peers with active local sockets."""
    peers = []
    for sock in SOCK_DIR.glob("datacore-msg-*.sock"):
        user = sock.stem.replace("datacore-msg-", "")
        peers.append(user)
    return peers


# === RELAY CLIENT ===

class RelayClient:
    """WebSocket client for relay server."""

    def __init__(self, url: str, secret: str, username: str):
        self.url = url
        self.secret = secret
        self.local_username = username
        self.ws = None
        self.username = None
        self.online_users = []
        self.message_callback = None
        self.presence_callback = None

    async def connect(self):
        """Connect and authenticate with relay."""
        if not HAS_WEBSOCKETS:
            raise RuntimeError("websockets package not installed. Run: pip install websockets")

        self.ws = await websockets.connect(self.url)

        # Authenticate with shared secret
        await self.ws.send(json.dumps({
            "type": "auth",
            "secret": self.secret,
            "username": self.local_username
        }))

        response = json.loads(await self.ws.recv())

        if response.get("type") == "auth_error":
            raise RuntimeError(f"Auth failed: {response.get('message')}")

        if response.get("type") == "auth_ok":
            self.username = response.get("username")
            self.online_users = response.get("online", [])
            return True

        return False

    async def send_message(self, to: str, text: str, msg_id: str, priority: str = "normal") -> dict:
        """Send message via relay."""
        await self.ws.send(json.dumps({
            "type": "send",
            "to": to,
            "text": text,
            "msg_id": msg_id,
            "priority": priority
        }))

        response = json.loads(await self.ws.recv())
        return response

    async def get_presence(self) -> list:
        """Get list of online users."""
        await self.ws.send(json.dumps({"type": "presence"}))
        response = json.loads(await self.ws.recv())
        if response.get("type") == "presence":
            self.online_users = response.get("online", [])
        return self.online_users

    async def listen(self):
        """Listen for incoming messages."""
        async for message in self.ws:
            data = json.loads(message)
            msg_type = data.get("type")

            if msg_type == "message":
                # Incoming message
                from_user = data.get("from")
                text = data.get("text")
                priority = data.get("priority", "normal")

                # Write to local inbox
                write_message_from_relay(from_user, text, priority)

                if self.message_callback:
                    await self.message_callback(data)

            elif msg_type == "presence_change":
                self.online_users = data.get("online", [])
                if self.presence_callback:
                    await self.presence_callback(data)

    async def close(self):
        """Close connection."""
        if self.ws:
            await self.ws.close()


def write_message_from_relay(from_user: str, text: str, priority: str = "normal") -> str:
    """Write message received from relay to local inbox."""
    to_user = get_username()
    space = get_default_space()

    inbox_dir = DATACORE_ROOT / space / "org/inboxes"
    inbox_dir.mkdir(parents=True, exist_ok=True)
    inbox = inbox_dir / f"{to_user}.org"

    now = datetime.now()
    msg_id = f"msg-{now.strftime('%Y%m%d-%H%M%S')}-{from_user}"
    timestamp = now.strftime("[%Y-%m-%d %a %H:%M]")

    entry = f"""
* MESSAGE {timestamp} :unread:
:PROPERTIES:
:ID: {msg_id}
:FROM: {from_user}
:TO: {to_user}
:PRIORITY: {priority}
:SOURCE: relay
:END:
{text}
"""

    with open(inbox, "a") as f:
        fcntl.flock(f, fcntl.LOCK_EX)
        f.write(entry)
        fcntl.flock(f, fcntl.LOCK_UN)

    return msg_id


async def notify_peer_relay(relay: RelayClient, user: str, text: str, msg_id: str, priority: str = "normal") -> bool:
    """Send notification to peer via relay."""
    try:
        response = await relay.send_message(user, text, msg_id, priority)
        return response.get("delivered", False)
    except:
        return False


# === DISPLAY ===

def display_messages(messages: list):
    """Display messages in terminal."""
    if not messages:
        print("No messages.")
        return

    print(f"\n{'â”€' * 50}")

    for msg in messages:
        marker = "â—" if msg["unread"] else " "
        priority = " [!]" if msg["priority"] == "high" else ""
        time_short = msg["time"].split(" ")[-1] if msg["time"] else ""

        print(f"{marker} @{msg['from']}{priority} ({time_short})")
        print(f"  {msg['text'][:80]}")
        if len(msg['text']) > 80:
            print(f"  ...")
        print()

    print(f"{'â”€' * 50}")
    print(f"â— = unread | {len(messages)} message(s)")


# === INTERACTIVE MODE ===

async def interactive_mode_local():
    """Interactive messaging mode (local only)."""
    username = get_username()
    print(f"datacore-msg | @{username} (local)")
    print("Commands: @user msg | /read | /peers | /quit")
    print()

    while True:
        try:
            line = await asyncio.get_event_loop().run_in_executor(
                None, lambda: input("> ")
            )
        except (EOFError, KeyboardInterrupt):
            break

        line = line.strip()
        if not line:
            continue

        if line.startswith("@"):
            # Send message
            parts = line.split(" ", 1)
            recipient = parts[0][1:]
            text = parts[1] if len(parts) > 1 else ""

            if not text:
                print("Usage: @user message")
                continue

            msg_id = write_message(recipient, text)
            notified = await notify_peer_local(recipient, msg_id)
            status = "âœ“ delivered" if notified else "âœ“ queued"
            print(f"  {status}")

        elif line == "/read":
            messages = read_messages(unread_only=False)
            display_messages(messages[-10:])

        elif line == "/unread":
            messages = read_messages(unread_only=True)
            display_messages(messages)

        elif line == "/peers":
            peers = list_online_peers_local()
            if peers:
                print(f"Online (local): {', '.join('@' + p for p in peers)}")
            else:
                print("No local peers online")

        elif line in ["/quit", "/q", "/exit"]:
            break

        else:
            print("Commands: @user msg | /read | /unread | /peers | /quit")


async def interactive_mode_relay():
    """Interactive messaging mode with relay connection."""
    if not HAS_WEBSOCKETS:
        print("Error: websockets package not installed")
        print("Run: pip install websockets")
        return

    secret = get_relay_secret()
    if not secret:
        print("Relay secret not configured.")
        print("Add to settings.local.yaml:")
        print("  messaging:")
        print("    relay:")
        print("      secret: your-shared-secret")
        return

    relay_url = get_relay_url()
    username = get_username()
    relay = RelayClient(relay_url, secret, username)

    try:
        await relay.connect()
    except Exception as e:
        print(f"Connection failed: {e}")
        return

    username = relay.username
    print(f"datacore-msg | @{username} (relay: {relay_url})")
    print(f"Online: {', '.join('@' + u for u in relay.online_users)}")
    print("Commands: @user msg | /read | /peers | /local | /quit")
    print()

    # Start listener in background
    async def on_message(data):
        from_user = data.get("from")
        text = data.get("text", "")[:50]
        print(f"\nðŸ”” @{from_user}: {text}")
        print("> ", end="", flush=True)

    async def on_presence(data):
        user = data.get("user")
        status = data.get("status")
        print(f"\n[{user} is now {status}]")
        print("> ", end="", flush=True)

    relay.message_callback = on_message
    relay.presence_callback = on_presence

    listener_task = asyncio.create_task(relay.listen())

    try:
        while True:
            try:
                line = await asyncio.get_event_loop().run_in_executor(
                    None, lambda: input("> ")
                )
            except (EOFError, KeyboardInterrupt):
                break

            line = line.strip()
            if not line:
                continue

            if line.startswith("@"):
                # Send message
                parts = line.split(" ", 1)
                recipient = parts[0][1:]
                text = parts[1] if len(parts) > 1 else ""

                if not text:
                    print("Usage: @user message")
                    continue

                # Write locally first
                msg_id = write_message(recipient, text)

                # Try relay
                delivered = await notify_peer_relay(relay, recipient, text, msg_id)

                # Fall back to local if not delivered via relay
                if not delivered:
                    delivered = await notify_peer_local(recipient, msg_id)

                status = "âœ“ delivered" if delivered else "âœ“ queued"
                print(f"  {status}")

            elif line == "/read":
                messages = read_messages(unread_only=False)
                display_messages(messages[-10:])

            elif line == "/unread":
                messages = read_messages(unread_only=True)
                display_messages(messages)

            elif line == "/peers":
                online = await relay.get_presence()
                local_peers = list_online_peers_local()
                all_peers = list(set(online + local_peers))
                if all_peers:
                    print(f"Online: {', '.join('@' + p for p in all_peers)}")
                else:
                    print("No peers online")

            elif line == "/local":
                # Switch to local mode
                print("Switching to local mode...")
                break

            elif line in ["/quit", "/q", "/exit"]:
                break

            else:
                print("Commands: @user msg | /read | /unread | /peers | /local | /quit")

    finally:
        listener_task.cancel()
        await relay.close()


async def interactive_mode():
    """Interactive mode - chooses relay or local based on settings."""
    if is_relay_enabled() and get_relay_secret():
        await interactive_mode_relay()
    else:
        await interactive_mode_local()


# === CLI ===

async def cmd_connect(args):
    """Handle connect command."""
    await interactive_mode_relay()


def main():
    parser = argparse.ArgumentParser(
        description="Datacore Terminal Messenger",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest="command")

    # send
    send_parser = subparsers.add_parser("send", help="Send a message")
    send_parser.add_argument("recipient", help="@username")
    send_parser.add_argument("message", nargs="+", help="Message text")
    send_parser.add_argument("--priority", "-p", default="normal",
                             choices=["low", "normal", "high"])

    # read
    read_parser = subparsers.add_parser("read", help="Read messages")
    read_parser.add_argument("--all", "-a", action="store_true",
                             help="Show all messages, not just unread")

    # watch
    subparsers.add_parser("watch", help="Watch for new messages")

    # peers
    subparsers.add_parser("peers", help="List online peers")

    # daemon
    subparsers.add_parser("daemon", help="Run notification daemon")

    # connect
    subparsers.add_parser("connect", help="Connect to relay server")

    args = parser.parse_args()

    if args.command == "send":
        recipient = args.recipient.lstrip("@")
        text = " ".join(args.message)
        msg_id = write_message(recipient, text, args.priority)

        async def send_with_notify():
            # Try relay first if enabled
            if is_relay_enabled():
                secret = get_relay_secret()
                if secret:
                    try:
                        relay = RelayClient(get_relay_url(), secret, get_username())
                        await relay.connect()
                        delivered = await notify_peer_relay(relay, recipient, text, msg_id, args.priority)
                        await relay.close()
                        if delivered:
                            return True
                    except:
                        pass

            # Fall back to local
            return await notify_peer_local(recipient, msg_id)

        notified = asyncio.run(send_with_notify())
        status = "delivered" if notified else "queued (offline)"
        print(f"âœ“ Sent to @{recipient} ({status})")

    elif args.command == "read":
        messages = read_messages(unread_only=not args.all)
        display_messages(messages)

    elif args.command == "watch":
        print("Watching for messages... (Ctrl+C to stop)")
        import time
        seen = set()
        try:
            while True:
                for msg in read_messages(unread_only=True):
                    if msg["id"] not in seen:
                        seen.add(msg["id"])
                        priority = " [!]" if msg["priority"] == "high" else ""
                        print(f"ðŸ”” @{msg['from']}{priority}: {msg['text'][:50]}")
                time.sleep(2)
        except KeyboardInterrupt:
            print("\nStopped.")

    elif args.command == "peers":
        peers = list_online_peers_local()

        # Also check relay if enabled
        if is_relay_enabled():
            secret = get_relay_secret()
            if secret:
                async def get_relay_peers():
                    try:
                        relay = RelayClient(get_relay_url(), secret, get_username())
                        await relay.connect()
                        online = await relay.get_presence()
                        await relay.close()
                        return online
                    except:
                        return []

                relay_peers = asyncio.run(get_relay_peers())
                peers = list(set(peers + relay_peers))

        if peers:
            print(f"Online: {', '.join('@' + p for p in peers)}")
        else:
            print("No peers online")

    elif args.command == "daemon":
        username = get_username()
        daemon = NotificationDaemon(username)
        try:
            asyncio.run(daemon.start())
        except KeyboardInterrupt:
            daemon.cleanup()
            print("\nDaemon stopped.")

    elif args.command == "connect":
        asyncio.run(cmd_connect(args))

    else:
        # Interactive mode (default)
        asyncio.run(interactive_mode())


if __name__ == "__main__":
    main()
